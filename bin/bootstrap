#!/usr/bin/env python
from dataclasses import dataclass
from enum import Enum
from os import makedirs, chmod
from signal import SIGINT, signal
from sys import exit
from typing import NamedTuple, Optional
import re
import subprocess as proc


CHROOT_PATH = '/mnt'
BOOT_DIR_PATH = f'{CHROOT_PATH}/boot'
SWAPFILE_PATH = f'{CHROOT_PATH}/swapfile'

BASE_PACKAGES = {
    'base',
    'linux-lts',
    'linux-firmware',
    'archlinux-keyring',
    'reflector',
    'efibootmgr',
    'grub',
    'sudo',
    'curl',
    'python',
}

PROMPT_INSTALL_CONFIRM = """
This install script assumes this computer boots with UEFI and is connected to the Internet through DHCP.
Any other type of configuration is not supported.
Confirm installation? (y/n)
=> """

PROMPT_INSTALL_DISK = """
Available disks:

{choices}

Which disk should Arch be installed to? (CAUTION: the disk will be completely erased!)
=> """

PROMPT_PROCESSOR_BRAND = """
What is the brand of your CPU? ({choices})
=> """


@dataclass(frozen=True)
class Disk:
    PATH_PATTERN = '/dev/[a-z]+'

    path: str

    def __post_init__(self) -> None:
        if not re.search(f'^{self.PATH_PATTERN}$', self.path):
            raise ValueError('Invalid disk path.')

    def __str__(self) -> str:
        return self.path


@dataclass(frozen=True)
class Partition:
    PATH_PATTERN = r'/dev/[a-z]+\d+'

    path: str

    def __post_init__(self) -> None:
        if not re.search(f'^{self.PATH_PATTERN}$', self.path):
            raise ValueError('Invalid disk partition path.')

    def __str__(self) -> str:
        return self.path


class PartitionMap(NamedTuple):
    boot: Partition
    root: Partition


class ProcessorBrand(Enum):
    AMD = 'amd'
    INTEL = 'intel'


@dataclass(frozen=True)
class ByteCount:
    amount: int

    def __post_init__(self) -> None:
        if self.amount <= 0:
            raise ValueError('Byte count must be a positive integer.')

    def __int__(self) -> int:
        return self.amount


class InstallParameters(NamedTuple):
    install_disk: Disk
    processor_brand: Optional[ProcessorBrand]
    total_memory: ByteCount


def _handle_sigint(signal: int, frame: Optional[object]):
    exit(1)


def _exec(cmd: str, *, capture_output: bool = False) -> proc.CompletedProcess:
    capture_args = {'stdout': proc.PIPE} if capture_output else {}

    return proc.run(cmd.split(), check=True, text=True, stderr=proc.STDOUT, **capture_args)


def _write_to_file(file_path: str, content: str) -> None:
    with open(file_path, mode='w') as file:
        print(content.strip(), file=file)


def _get_available_disks() -> set[str]:
    fdisk_output = _exec('fdisk --list', capture_output=True).stdout
    disks = re.findall(f'^Disk ({Disk.PATH_PATTERN}):', fdisk_output, re.M)

    return {disk for disk in disks if not re.search(r'^/dev/loop\d+$', disk)}


def _get_total_memory() -> ByteCount:
    free_output = _exec('free --bytes', capture_output=True).stdout
    match = re.search(r'^Mem: +(?P<bytes>\d+) ', free_output, flags=re.M)

    return ByteCount(amount=int(match.group('bytes')))


def confirm_installation() -> None:
    response = None

    while response not in {'Y', 'y', 'N', 'n'}:
        response = input(PROMPT_INSTALL_CONFIRM)

    if response in {'N', 'n'}:
        exit(1)


def select_install_disk() -> Disk:
    disk_choices = _get_available_disks()
    install_disk = None
    prompt = PROMPT_INSTALL_DISK.format(choices='\n'.join([f' -> {disk}' for disk in disk_choices]))

    while install_disk not in disk_choices:
        install_disk = input(prompt)

    return Disk(path=install_disk)


def select_processor_brand() -> Optional[ProcessorBrand]:
    proc_brands = {
        **{member.value: member for member in ProcessorBrand},
        'other': None,
    }
    proc_choices = proc_brands.keys()
    proc_brand = None
    prompt = PROMPT_PROCESSOR_BRAND.format(choices=', '.join(proc_choices))

    while proc_brand not in proc_choices:
        proc_brand = input(prompt)

    return proc_brands[proc_brand]


def gather_install_parameters() -> InstallParameters:
    return InstallParameters(
        install_disk=select_install_disk(),
        processor_brand=select_processor_brand(),
        total_memory=_get_total_memory(),
    )


def stop_reflector() -> None:
    print('\nStopping Reflector service...')

    _exec('systemctl stop reflector')


def enable_ntp() -> None:
    print('\nActivating NTP time synchronization...')

    _exec('timedatectl set-ntp 1')


def wipe_disk(disk: Disk) -> None:
    print(f'\nWiping disk {disk}...')

    _exec(f'wipefs --all {disk}')


def partition_disk(disk: Disk) -> PartitionMap:
    print(f'\nPartitioning disk {disk}...')

    _exec(f'parted {disk} mklabel gpt')
    _exec(f'parted {disk} mkpart uefi_boot fat32 1MiB 321MiB')
    _exec(f'parted {disk} mkpart root ext4 321MiB 100%')
    _exec(f'parted {disk} set 1 esp on')

    return PartitionMap(
        boot=Partition(f'{disk}1'),
        root=Partition(f'{disk}2')
    )


def format_partitions(partitions: PartitionMap) -> None:
    print('\nFormatting partitions...')

    _exec(f'mkfs.fat -F 32 {partitions.boot}')
    _exec(f'mkfs.ext4 {partitions.root}')


def mount_partitions(partitions: PartitionMap) -> None:
    print('\nMounting partitions...')

    _exec(f'mount --options noatime {partitions.root} {CHROOT_PATH}')
    makedirs(BOOT_DIR_PATH, mode=0o755, exist_ok=True)
    _exec(f'mount --options noatime {partitions.boot} {BOOT_DIR_PATH}')


def create_swapfile(size: ByteCount) -> None:
    print('\nCreating swapfile...')

    _exec(f'fallocate --length {int(size)} {SWAPFILE_PATH}')
    chmod(SWAPFILE_PATH, 0o600)
    _exec(f'mkswap {SWAPFILE_PATH}')


def enable_swap() -> None:
    print('\nEnabling swap...')

    _exec(f'swapon {SWAPFILE_PATH}')


def update_mirror_list() -> None:
    print('\nUpdating mirror list...')

    _exec('reflector --verbose --protocol https --country France --latest 10 --sort rate --save /etc/pacman.d/mirrorlist')


def init_pacman_keyring() -> None:
    print('\nInitializing pacman keyring...')

    _exec('pacman-key --init')
    _exec('pacman-key --populate archlinux')


def install_base_system(processor_brand: Optional[ProcessorBrand]) -> None:
    print('\nInstalling base system...')

    base_packages = BASE_PACKAGES.copy()

    if processor_brand is not None:
        base_packages.add(f'{processor_brand.value}-ucode')

    _exec(f'pacstrap {CHROOT_PATH} {" ".join(base_packages)}')


def generate_fstab() -> None:
    print('\nGenerating fstab...')

    fstab = _exec(f'genfstab -U {CHROOT_PATH}', capture_output=True).stdout

    for pattern in {r'\t+', ' {2,}'}:
        fstab = re.sub(pattern, ' ', fstab, flags=re.M)

    _write_to_file(f'{CHROOT_PATH}/etc/fstab', fstab)


def main() -> None:
    signal(SIGINT, _handle_sigint)

    confirm_installation()
    install_params = gather_install_parameters()

    stop_reflector()
    enable_ntp()

    wipe_disk(install_params.install_disk)
    partitions = partition_disk(install_params.install_disk)
    format_partitions(partitions)
    mount_partitions(partitions)
    create_swapfile(install_params.total_memory)
    enable_swap()

    update_mirror_list()
    init_pacman_keyring()
    install_base_system(install_params.processor_brand)

    generate_fstab()


main()
